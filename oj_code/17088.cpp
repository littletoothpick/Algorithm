#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

int MAX_COUNT = 0;
int NUM = 0;

void split(int array[], int n, int &l, int &r)
{
    int mid = n/2;
    for(l=0; l<n; l++)
    {
        if(array[l] == array[mid])
            break;
    }

    for(r=l+1; r<n; r++)
    {
        if(array[r] != array[mid])
            break;
    }
}

void get_num(int array[], int n){
    int l,r,count;
    split(array, n, l, r);
    count = r-l;

    if(count > MAX_COUNT)
    {
        MAX_COUNT = count;
        NUM = array[n/2];
    }

    if(l+1 > MAX_COUNT)
    {
        get_num(array, l+1);
    }

    if(n-r > MAX_COUNT)
    {
        get_num(array+r, n-r);
    }

}

int main()
{
    int n;
    scanf("%d", &n);
    int *a = new int[n];
    for(int i=0; i<n; i++)
    {
        scanf("%d", &a[i]);
    }
    sort(a, a+n);
    get_num(a, n);
    cout<<NUM<<" "<<MAX_COUNT;
    return 0;
}

/**
*
给定含有n个元素的多重集合S，每个元素在S中出现的次数称为该元素的重数。多重集S中重数最大的元素称为
众数。例如，S={1，2，2，2，3，5}。多重集S的众数是2，其重数为3。

求众数方法很多，现要求你用分治算法来试一试，并分析其效率。

编程任务：对于给定的由n个自然数组成的多重集S，采用分治算法编程计算S的众数及其重数。
*/

/**
解法一：（简单映射的解法）
用一个长度为最大元素值的数组作为n个元素出现重数的计数。这种方法时间复杂度为O(n)，但空间
复杂度较大些，空间依赖于原数组的规模。

解法二：（散列表映射的解法）
同解法一，只是采用散列表代替数组的映射，当散列表的负载因子小于0.5时，大部分情况下检索
长度小于2，但若负载因子超过0.5，散列表性能也将下降。

解法三：（排序法）
将n个元素排序，相同元素将出现到一起，对排序后的数组从左到右一遍扫描，边扫描边统计，
即可以找出具有最长相同元素序列的众数。此方法由于要排序，时间复杂度做不到线性，需
要O(nlogn)。空间上需求较少，除了原数组外，只需要记录从左扫过来的当前出现最多的元素
和当前出现最多元素出现的次数，可以认为空间需求O(1)。

解法四：（分治算法）
1，先求n个元素的中位数及其位置，并且把数组中与中位数相同的数字靠拢，可以统计中位数
个数（中位数因相同可能存在多个）；
2，以中位数做划分，划分为比中位数小的左段和比中位数大的右端，数组被中间相等的数分开
成两部分，有递归的条件了：先看左边，若中位数的个数比左边这段短，说明左边可能找到重数
更多的，所以对左边段的递归继续；反之，如果左边这段的长度更短，就没有必要对左段继续递
归。对右边那段数据采用同样的递归策略。
当左右段都找到同样重数（都大于中间中位数个数，且重数相等），优先输出左段的众数。

时间效率分析：因为递归的两个子段都能以接近1/2倍率缩短，最坏情况下左右两段都要递归，
所以T(n)=2T(n/2)+O(n) T(1)=1，因此T(n)=O(nlogn)。特别的，当中位数是主元素时（元素
个数大于等于1/2的元素称为主元素），只需要O(n)，一般情况下整个算法应该是介于O(n)和
O(nlogn)之间。
分析空间上，除了原数组以外无需太多辅助的空间。
*/
